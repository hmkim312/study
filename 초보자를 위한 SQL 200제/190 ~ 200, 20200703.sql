-- #190 SQL로 머신러닝 구현하기(12) : support vector machine)
-- 유방에 있는 종양의 크기와 모양 등의 데이터로 종양이 악성인지 양성인지 예측
-- 테이블 생성 후 데이터 입력
DROP TABLE WISC_BC_DATA;

CREATE TABLE WISC_BC_DATA
( ID	                 NUMBER(10),
DIAGNOSIS	         VARCHAR2(5), 
RADIUS_MEAN	         NUMBER(20,7),
TEXTURE_MEAN	         NUMBER(20,7),
PERIMETER_MEAN	         NUMBER(20,7),
AREA_MEAN	         NUMBER(20,7),
SMOOTHNESS_MEAN      NUMBER(20,7),
COMPACTNESS_MEAN     NUMBER(20,7),
CONCAVITY_MEAN	         NUMBER(20,7),
POINTS_MEAN	         NUMBER(20,7),
SYMMETRY_MEAN	         NUMBER(20,7),
DIMENSION_MEAN	         NUMBER(20,7),
RADIUS_SE	         NUMBER(20,7),
TEXTURE_SE	         NUMBER(20,7),
PERIMETER_SE	         NUMBER(20,7),
AREA_SE	                      NUMBER(20,7),
SMOOTHNESS_SE	         NUMBER(20,7),
COMPACTNESS_SE	         NUMBER(20,7),
CONCAVITY_SE	         NUMBER(20,7),
POINTS_SE	         NUMBER(20,7),
SYMMETRY_SE	         NUMBER(20,7),
DIMENSION_SE	         NUMBER(20,7),
RADIUS_WORST	         NUMBER(20,7),
TEXTURE_WORST	         NUMBER(20,7),
PERIMETER_WORST	         NUMBER(20,7),
AREA_WORST	         NUMBER(20,7),
SMOOTHNESS_WORST	 NUMBER(20,7),
COMPACTNESS_WORST	 NUMBER(20,7),
CONCAVITY_WORST            NUMBER(20,7),
POINTS_WORST	         NUMBER(20,7),
SYMMETRY_WORST	         NUMBER(20,7),
DIMENSION_WORST          NUMBER(20,7) );

-- 훈련데이터와 테스트 데이터로 분리
DROP TABLE WISC_BC_DATA_TRAINING;

CREATE TABLE WISC_BC_DATA_TRAINING
AS
SELECT *
   FROM WISC_BC_DATA 
   WHERE ROWNUM < 501;

DROP TABLE WISC_BC_DATA_TEST; 

CREATE TABLE WISC_BC_DATA_TEST
AS
SELECT *
  FROM WISC_BC_DATA
MINUS
SELECT *
  FROM WISC_BC_DATA_TRAINING;
  
-- 모델 구성정보 테이블 생성
DROP TABLE DTSETTINGS;

CREATE TABLE DTSETTINGS
AS
SELECT *
  FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
   WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_SUPPORT_VECTOR_MACHINES');

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.SVMS_KERNEL_FUNCTION, 'SVMS_GAUSSIAN');

   COMMIT;
END;
/

-- 서포트 벡터 머신 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('WC_MODEL');
END;
/

BEGIN
   DBMS_DATA_MINING.CREATE_MODEL (
      MODEL_NAME            => 'WC_MODEL',
      MINING_FUNCTION       => DBMS_DATA_MINING.CLASSIFICATION,
      DATA_TABLE_NAME       => 'WISC_BC_DATA_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'DIAGNOSIS',
      SETTINGS_TABLE_NAME   => 'DTSETTINGS');
END;
/

-- 머신러닝 모델 확인
SELECT MODEL_NAME,
        ALGORITHM,
        MINING_FUNCTION
    FROM ALL_MINING_MODELS
    WHERE MODEL_NAME = 'WC_MODEL';
    
-- 머신러닝 모델의 구성정보 확인
SELECT SETTING_NAME, SETTING_VALUE
    FROM ALL_MINING_MODEL_SETTINGS
    WHERE MODEL_NAME = 'WC_MODEL';
    
-- 서포트 벡터머신의 모델 성능 정보 확인
DROP TABLE WC_DATA_TEST_MATRIX;
      
CREATE OR REPLACE VIEW VIEW_WISC_BC_DATA_TEST
AS
SELECT ID, DIAGNOSIS, 
          PREDICTION(WC_MODEL USING *) PREDICTED_VALUE,
          PREDICTION_PROBABILITY(WC_MODEL USING * ) PROBABILITY
 FROM WISC_BC_DATA_TEST;
 
-- 예측확인
SELECT ID 환자번호, DIAGNOSIS 실제값, PREDICTED_VALUE 예측값, PROBABILITY 예측확률
  FROM VIEW_WISC_BC_DATA_TEST;
  
-- 성능 확인
SET  SERVEROUTPUT ON

DECLARE
   V_ACCURACY NUMBER;
BEGIN
   DBMS_DATA_MINING.COMPUTE_CONFUSION_MATRIX (
      ACCURACY => V_ACCURACY,
      APPLY_RESULT_TABLE_NAME => 'VIEW_WISC_BC_DATA_TEST',
      TARGET_TABLE_NAME => 'WISC_BC_DATA_TEST',
      CASE_ID_COLUMN_NAME => 'ID',
      TARGET_COLUMN_NAME => 'DIAGNOSIS',
      CONFUSION_MATRIX_TABLE_NAME => 'WC_DATA_TEST_MATRIX',
      SCORE_COLUMN_NAME => 'PREDICTED_VALUE',
      SCORE_CRITERION_COLUMN_NAME => 'PROBABILITY',
      COST_MATRIX_TABLE_NAME => NULL,
      APPLY_RESULT_SCHEMA_NAME => NULL,
      TARGET_SCHEMA_NAME => NULL,
      COST_MATRIX_SCHEMA_NAME => NULL,
      SCORE_CRITERION_TYPE => 'PROBABILITY');
   DBMS_OUTPUT.PUT_LINE('**** MODEL ACCURACY ****: ' || ROUND(V_ACCURACY,4));
END;
/

-- #191 SQL로 머신러닝 구현하기(13) : SUPPORT VECTOR  MACHINE
-- 유방암의 종양이 악성인지 양성인지 예측하는 서포트 벡터머신 모델의 커널을 변경
DROP TABLE DTSETTINGS;

CREATE TABLE DTSETTINGS
( SETTING_NAME    VARCHAR2 (200),
 SETTING_VALUE   VARCHAR2 (200) );

BEGIN

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_SUPPORT_VECTOR_MACHINES');

   INSERT INTO DTSETTINGS
      VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.SVMS_KERNEL_FUNCTION, 'SVMS_LINEAR');

COMMIT;
END;
/

-- 모델을 SVMS_LINEAR로 설정하여 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('WC_MODEL');
END;
/

BEGIN
   DBMS_DATA_MINING.CREATE_MODEL (
      MODEL_NAME            => 'WC_MODEL',
      MINING_FUNCTION       => DBMS_DATA_MINING.CLASSIFICATION,
      DATA_TABLE_NAME       => 'WISC_BC_DATA_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'DIAGNOSIS',
      SETTINGS_TABLE_NAME   => 'DTSETTINGS');
END;
/

-- 생성된 모델 확인
SELECT MODEL_NAME,
        ALGORITHM,
        MINING_FUNCTION
    FROM ALL_MINING_MODELS
    WHERE MODEL_NAME = 'WC_MODEL';
    
-- 구성정보 확인 SVMS_LINEAR
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'WC_MODEL';
  
-- 생성한 머신러닝 모델의 성능을 확인
DROP TABLE WC_DATA_TEST_MATRIX;
      
CREATE OR REPLACE VIEW   VIEW_WISC_BC_DATA_TEST
AS
SELECT ID, PREDICTION(WC_MODEL USING *) PREDICTED_VALUE,
          PREDICTION_PROBABILITY(WC_MODEL USING * ) PROBABILITY
  FROM WISC_BC_DATA_TEST;
  
set serveroutput on  
  
DECLARE
   V_ACCURACY NUMBER;
BEGIN
   DBMS_DATA_MINING.COMPUTE_CONFUSION_MATRIX (
      ACCURACY           => V_ACCURACY,
      APPLY_RESULT_TABLE_NAME => 'VIEW_WISC_BC_DATA_TEST',
      TARGET_TABLE_NAME       => 'WISC_BC_DATA_TEST',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME   => 'DIAGNOSIS',
      CONFUSION_MATRIX_TABLE_NAME => 'WC_DATA_TEST_MATRIX',
      SCORE_COLUMN_NAME       => 'PREDICTED_VALUE',
      SCORE_CRITERION_COLUMN_NAME => 'PROBABILITY',
      COST_MATRIX_TABLE_NAME      => NULL,
      APPLY_RESULT_SCHEMA_NAME   => NULL,
      TARGET_SCHEMA_NAME       => NULL,
      COST_MATRIX_SCHEMA_NAME => NULL,
      SCORE_CRITERION_TYPE   => 'PROBABILITY');
   DBMS_OUTPUT.PUT_LINE('**** MODEL ACCURACY ****: ' || ROUND(V_ACCURACY,4));
END;
/

-- #192 SQL로 머신러닝 구현하기(14) : SUPPORT VECTOR MACHINE
-- 환자번호를 입력하면 예측한 결과를 출력
SET SERVEROUTPUT ON
SET VERIFY OFF

ACCEPT P_ID PROMPT '환자 번호를 입력하세요~ (예: 845636)'

DECLARE  
   V_PRED    VARCHAR2(20);
   V_PROB    NUMBER(10,2);

BEGIN

SELECT PREDICTION (WC_MODEL USING *),
          PREDICTION_PROBABILITY(WC_MODEL  USING * )  INTO V_PRED, V_PROB
  FROM WISC_BC_DATA_TEST
  WHERE ID = '&P_ID';

 IF V_PRED ='M' THEN 

   DBMS_OUTPUT.PUT_LINE('머신러닝이 예측한 결과: 유방암 환자입니다. 유방암일 확률은 ' || ROUND(V_PROB,2) * 100 || '%입니다');

 ELSE 
    DBMS_OUTPUT.PUT_LINE('머신러닝이 예측한 결과: 유방암 환자가 아닙니다. 유방암 환자가 아닐 확률은 ' || ROUND(V_PROB,2) * 100 || '%입니다');

 END IF;

END;
/

-- #193 SQL로 머신러닝 구현하기(15) : REGRESSION
-- 학생점수로 회귀분석 해보기
-- 학생 점수 테이블 생성
-- 데이터 입력: SQL Developer를 이용해서 student_score.csv 를 STUDENT_SCORE 테이블에 입력
DROP TABLE STUDENT_SCORE;

CREATE TABLE STUDENT_SCORE
(  ST_ID        NUMBER(10),
  ACADEMIC   NUMBER(20,8),
  SPORTS      NUMBER(30,10),
  MUSIC       NUMBER(30,10),
 ACCEPTANCE  NUMBER(30,10) );

-- 훈련 데이터와 테스트 데이터로 분리
DROP TABLE STUDENT_SCORE_TRAINING; 

CREATE TABLE STUDENT_SCORE_TRAINING
AS
   SELECT *
     FROM STUDENT_SCORE
     WHERE ST_ID < 181;

DROP TABLE STUDENT_SCORE_TEST;

CREATE TABLE STUDENT_SCORE_TEST
AS
   SELECT *
     FROM STUDENT_SCORE
     WHERE ST_ID >= 181;
    
-- 회귀분석을 위한 머신러닝 모델 구성 테이블 생성
DROP TABLE SETTINGS_REG1;

CREATE TABLE SETTINGS_REG1
AS
SELECT *
     FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
     WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

INSERT INTO SETTINGS_REG1
  VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_GENERALIZED_LINEAR_MODEL');

INSERT INTO SETTINGS_REG1
  VALUES (DBMS_DATA_MINING.PREP_SCALE_2DNUM, 'PREP_SCALE_RANGE');

COMMIT;

END;
/

-- 회귀모델 생성
BEGIN
 DBMS_DATA_MINING.DROP_MODEL('MD_REG_MODEL1');
END;
/

BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_REG_MODEL1',
      MINING_FUNCTION       => DBMS_DATA_MINING.REGRESSION,
      DATA_TABLE_NAME       => 'STUDENT_SCORE_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ST_ID',
      TARGET_COLUMN_NAME    => 'ACCEPTANCE',
      SETTINGS_TABLE_NAME   => 'SETTINGS_REG1');
END;
/

-- 모델 생성 여부를 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_REG_MODEL1';


-- 모델 구성 정보를 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'MD_REG_MODEL1';


-- 테스트 데이터에 대해 회귀분석 모델이 예측한 예측점수를 확인 
SELECT ST_ID 학생번호, ACADEMIC 학과점수, ROUND(MUSIC,2) 음악점수 , 
          SPORTS 체육점수, ROUND(ACCEPTANCE,2) AS 실제점수, ROUND(MODEL_PREDICT_RESPONSE,2) AS 예측점수
 FROM ( 
           SELECT T.*, PREDICTION (MD_REG_MODEL1 USING *) MODEL_PREDICT_RESPONSE
             FROM STUDENT_SCORE_TEST T
      );


-- 회귀 모델의 결정계수 R 스퀘어 값을 확인
SELECT *
  FROM TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_GLOBAL(MODEL_NAME =>  'MD_REG_MODEL1'))
  WHERE GLOBAL_DETAIL_NAME IN ('R_SQ','ADJUSTED_R_SQUARE');


-- 입학점수에 영향력 있는 변수가 무엇인지 확인
SELECT ATTRIBUTE_NAME, COEFFICIENT
  FROM TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLM ('MD_REG_MODEL1'));
  
-- #194 SQL로 머신러닝 구현하(16) : REGRESSION
-- 미국 국민들의 의료비 지출에 영향력을 크게 미치는 요소가 무엇인지 확인
-- 테이블 생성
DROP TABLE INSURANCE;

CREATE TABLE INSURANCE
( ID         NUMBER(10),
  AGE       NUMBER(3),
  SEX        VARCHAR2(10),
  BMI        NUMBER(10,2),
  CHILDREN  NUMBER(2),
  SMOKER    VARCHAR2(10),
  REGION    VARCHAR2(20), 
  EXPENSES  NUMBER(10,2) );
  
-- 데이터 입력: SQL Developer를 이용해서 insurance.csv 를 insurance 테이블에 입력합니다. 
select count(*) from INSURANCE;
  
-- 훈련 데이터와 테스트 데이터로 분리
DROP TABLE INSURANCE_TRAINING; 

CREATE TABLE INSURANCE_TRAINING
AS
   SELECT *
     FROM INSURANCE
     WHERE ID < 1114;

DROP TABLE INSURANCE_TEST;

CREATE TABLE INSURANCE_TEST
AS
   SELECT *
     FROM INSURANCE
     WHERE ID >= 1114;

-- 머신러닝 모델의 환경 구성 테이블을 생성

DROP TABLE SETTINGS_REG2;

CREATE TABLE SETTINGS_REG2
AS
SELECT *
  FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
  WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

INSERT INTO SETTINGS_REG2
 VALUES (DBMS_DATA_MINING.ALGO_NAME,'ALGO_GENERALIZED_LINEAR_MODEL');

INSERT INTO SETTINGS_REG2
 VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

COMMIT;

END;
/

-- 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_REG_MODEL2');
END;
/

BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_REG_MODEL2',
      MINING_FUNCTION       => DBMS_DATA_MINING.REGRESSION,
      DATA_TABLE_NAME       => 'INSURANCE_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'EXPENSES',
      SETTINGS_TABLE_NAME   => 'SETTINGS_REG2');
END;
/

-- 생성된 머신러닝 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_REG_MODEL2';

-- 머신러닝 모델 구성 정보를 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'MD_REG_MODEL2';

-- 회귀분석 모델의 회귀계수를 확인
SELECT ATTRIBUTE_NAME, ATTRIBUTE_VALUE, ROUND(COEFFICIENT)
  FROM TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLM ('MD_REG_MODEL2'));

-- 예측 값을 확인
SELECT ID, AGE, SEX, EXPENSES, 
          ROUND(PREDICTION (MD_REG_MODEL2 USING *),2) MODEL_PREDICT_RESPONSE
  FROM INSURANCE_TEST T;

-- 결정계수 R 스퀘어 값 확인
SELECT GLOBAL_DETAIL_NAME, ROUND(GLOBAL_DETAIL_VALUE,3)
  FROM
  TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_GLOBAL(MODEL_NAME =>'MD_REG_MODEL2'))
  WHERE  GLOBAL_DETAIL_NAME IN ('R_SQ','ADJUSTED_R_SQUARE');
  
-- #195 SQL로 머신러닝 구현하기(17) : 파생변수 생성
-- 비만인 사람이 흡연까지 하게되면 의료비가 더 증가되는지 확인
-- 파생변수 컬럼 추가
ALTER TABLE INSURANCE
  DROP COLUMN BMI30;

ALTER TABLE INSURANCE
  ADD BMI30 NUMBER(10);

UPDATE INSURANCE   I
   SET BMI30 = ( SELECT CASE WHEN BMI >= 30 AND SMOKER='yes'
                                THEN  1  ELSE  0  END 
                        FROM INSURANCE S
                        WHERE S.ROWID = I.ROWID) ;
COMMIT;


-- 훈련 데이터와 테스트 데이터를 9대 1로 분리
DROP TABLE INSURANCE_TRAINING; 

CREATE TABLE INSURANCE_TRAINING
AS
   SELECT *
     FROM INSURANCE
     WHERE ID < 1114;

DROP TABLE INSURANCE_TEST;

CREATE TABLE INSURANCE_TEST
AS
   SELECT *
     FROM INSURANCE
    WHERE ID >= 1114;

-- 머신러닝 모델을 생성

BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_REG_MODEL3');
END;
/

BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_REG_MODEL3',
      MINING_FUNCTION       => DBMS_DATA_MINING.REGRESSION,
      DATA_TABLE_NAME       => 'INSURANCE_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'EXPENSES',
      SETTINGS_TABLE_NAME   => 'SETTINGS_REG2');
END;
/

-- 생성된 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_REG_MODEL3';

-- 회귀 모수를 확인
SELECT ATTRIBUTE_NAME, ATTRIBUTE_VALUE, ROUND(COEFFICIENT)
  FROM 
  TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLM ('MD_REG_MODEL3'));

-- R 스퀘어 값 확인
SELECT GLOBAL_DETAIL_NAME, ROUND(GLOBAL_DETAIL_VALUE,3)
  FROM
  TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_GLOBAL(MODEL_NAME =>'MD_REG_MODEL3'))
  WHERE  GLOBAL_DETAIL_NAME IN ('R_SQ','ADJUSTED_R_SQUARE');

-- #196 SQL로 머신러닝 구현하기(18) : 파생변수 생성
-- 국민 의료비 데이터를 회귀분석하여 나이가 들수록 의료비가 증가하는지 확인
-- 기존 나이의 제곱값인 새로운 파생변수 추가
ALTER TABLE INSURANCE
  DROP COLUMN AGE2;

ALTER TABLE INSURANCE
  ADD AGE2 NUMBER(10);

UPDATE INSURANCE
  SET AGE2 = AGE * AGE ;

COMMIT;

--훈련 데이터와 테스트 데이터를 9대1로 분리 
DROP TABLE INSURANCE_TRAINING; 

CREATE TABLE INSURANCE_TRAINING
AS
   SELECT *
     FROM INSURANCE
     WHERE ID < 1114;

DROP TABLE INSURANCE_TEST;

CREATE TABLE INSURANCE_TEST
AS
   SELECT *
     FROM INSURANCE
    WHERE ID >= 1114;

-- 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_REG_MODEL4');
END;
/

BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_REG_MODEL4',
      MINING_FUNCTION       => DBMS_DATA_MINING.REGRESSION,
      DATA_TABLE_NAME       => 'INSURANCE_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'EXPENSES',
      SETTINGS_TABLE_NAME   => 'SETTINGS_REG2');
END;
/

-- 머신러닝 모델이 잘 생성되었는지 확인
SELECT MODEL_NAME,
          ALGORITHM,
          CREATION_DATE,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_REG_MODEL4';


-- 회귀 계수를 확인
SELECT ATTRIBUTE_NAME, ATTRIBUTE_VALUE, ROUND(COEFFICIENT)
  FROM 
  TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLM ('MD_REG_MODEL4'));

-- R 스퀘어 값을 확인
SELECT GLOBAL_DETAIL_NAME, ROUND(GLOBAL_DETAIL_VALUE,3)
  FROM TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLOBAL(MODEL_NAME => 'MD_REG_MODEL4'))
  WHERE GLOBAL_DETAIL_NAME IN ('R_SQ','ADJUSTED_R_SQUARE');
  
-- #197 SQL로 머신러닝 구현하기(19) : APRIORI
-- 남성의 맥주와 기저귀 구매 연관성 분석
-- 테이블 생성
DROP TABLE MARKET_TABLE; 

CREATE TABLE MARKET_TABLE
  ( CUST_ID         NUMBER(10),
    STOCK_CODE    NUMBER(10),
    STOCK_NAME   VARCHAR2(30),
    QUANTITY      NUMBER(10),
    STOCK_PRICE   NUMBER(10,2),
    BUY_DATE      DATE  );
        
-- sqldeveloper 를 이용하여 market.csv 데이터를 로드합니다. 
select count(*) from market_table;

-- 연관성 분석을 위한 환경 구성 테이블을 생성
DROP TABLE SETTINGS_ASSOCIATION_RULES;

CREATE TABLE SETTINGS_ASSOCIATION_RULES
AS
   SELECT *
     FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
     WHERE SETTING_NAME LIKE 'ASSO_%';

BEGIN
   UPDATE SETTINGS_ASSOCIATION_RULES
      SET SETTING_VALUE = 3
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MAX_RULE_LENGTH;

   UPDATE SETTINGS_ASSOCIATION_RULES
      SET SETTING_VALUE = 0.03
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MIN_SUPPORT;

    UPDATE SETTINGS_ASSOCIATION_RULES
      SET SETTING_VALUE = 0.03
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MIN_CONFIDENCE;

   INSERT INTO SETTINGS_ASSOCIATION_RULES
        VALUES (DBMS_DATA_MINING.ODMS_ITEM_ID_COLUMN_NAME, 'STOCK_CODE');

   COMMIT;
END;
/


-- 연관성 분석을 위한 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_ASSOC_ANLYSIS');
END;
/

CREATE OR REPLACE VIEW VW_MARKET_TABLE 
AS 
SELECT CUST_ID, STOCK_CODE 
  FROM MARKET_TABLE;


BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_ASSOC_ANLYSIS',
      MINING_FUNCTION       => DBMS_DATA_MINING.ASSOCIATION,
      DATA_TABLE_NAME       => 'VW_MARKET_TABLE',
      CASE_ID_COLUMN_NAME   => 'CUST_ID',
      TARGET_COLUMN_NAME    => NULL,
      SETTINGS_TABLE_NAME   => 'SETTINGS_ASSOCIATION_RULES');
END;
/

-- 머신러닝 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_ASSOC_ANLYSIS';


-- 머신러닝 모델 구성 정보를 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'MD_ASSOC_ANLYSIS';

-- 모델이 분석한 연관분석 결과를 확인
SELECT A.ATTRIBUTE_SUBNAME as ANTECEDENT,
          C.ATTRIBUTE_SUBNAME as CONSEQUENT,
          ROUND(RULE_SUPPORT,3) as SUPPORT,
          ROUND(RULE_CONFIDENCE,3) as CONFIDENCE,
          ROUND(RULE_LIFT,3) as LIFT
  FROM  TABLE(DBMS_DATA_MINING.GET_ASSOCIATION_RULES('MD_ASSOC_ANLYSIS',10)) T,
            TABLE(T.CONSEQUENT) C,
            TABLE(T.ANTECEDENT) A
  ORDER BY SUPPORT DESC,LIFT  DESC;

-- #198 SQL로 머신러닝 구현하기(20) : APRIORI
-- 아프리오리 알고리즘을 이용하여 온라인으로 물건을 구매하는 고객들에게 구매하고자 하는 상품과 연관성이 있는 상품을 추천하는 모델 생성
-- 테이블 생성
DROP TABLE ONLINE_RETAIL; 

CREATE TABLE ONLINE_RETAIL
( INVOICENO    VARCHAR2(100),
  STOCKCODE    VARCHAR2(100),
  DESCRIPTION  VARCHAR2(200),
  QUANTITY     NUMBER(10,2),
  INVOICEDATE  DATE,
  UNITPRICE    NUMBER(10,2),
  CUSTOMERID  NUMBER(10,2),
  COUNTRY     VARCHAR2(100) );
  
-- 데이터 입력: SQL Developer를 이용해서 Online Retail.csv 를 ONLINE_RETAIL 테이블에 입력
SELECT COUNT(*)  FROM ONLINE_RETAIL;


-- 연관성 분석을 위한 머신러닝 환경을 셋팅
DROP TABLE SETTINGS_ASSOCIATION_RULES2;

CREATE TABLE SETTINGS_ASSOCIATION_RULES2
AS
   SELECT *
     FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
     WHERE SETTING_NAME LIKE 'ASSO_%';

BEGIN
   UPDATE SETTINGS_ASSOCIATION_RULES2
     SET SETTING_VALUE = 3
     WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MAX_RULE_LENGTH;

   UPDATE SETTINGS_ASSOCIATION_RULES2
      SET SETTING_VALUE = 0.03
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MIN_SUPPORT;

    UPDATE SETTINGS_ASSOCIATION_RULES2
      SET SETTING_VALUE = 0.03
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MIN_CONFIDENCE;

   INSERT INTO SETTINGS_ASSOCIATION_RULES2
      VALUES (DBMS_DATA_MINING.ODMS_ITEM_ID_COLUMN_NAME, ' INVOICENO');
   COMMIT;
END;
/


-- 학습할 데이터만 선별하여 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_ASSOC_ANLYSIS2');
END;
/

CREATE OR REPLACE VIEW VW_ONLINE_RETAIL
 AS 
   SELECT INVOICENO, STOCKCODE
       FROM ONLINE_RETAIL;

BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_ASSOC_ANLYSIS2',
      MINING_FUNCTION       => DBMS_DATA_MINING.ASSOCIATION,
      DATA_TABLE_NAME       => 'VW_ONLINE_RETAIL',
      CASE_ID_COLUMN_NAME   => 'STOCKCODE',
      TARGET_COLUMN_NAME    => NULL,
      SETTINGS_TABLE_NAME   => 'SETTINGS_ASSOCIATION_RULES2');
END;
/

-- 머신러닝 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_ASSOC_ANLYSIS2';

-- 머신러닝 모델의 환경 설정을 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'MD_ASSOC_ANLYSIS2';

-- 모델이 분석한 상품 간의 연관성을 확인
SELECT A.ATTRIBUTE_SUBNAME as ANTECEDENT,
       C.ATTRIBUTE_SUBNAME as CONSEQUENT,
       ROUND(RULE_SUPPORT,3) as SUPPORT,
       ROUND(RULE_CONFIDENCE,3) as CONFIDENCE,
       ROUND(RULE_LIFT,3) as LIFT
  FROM  TABLE(DBMS_DATA_MINING.GET_ASSOCIATION_RULES('MD_ASSOC_ANLYSIS2',10)) T,
            TABLE(T.CONSEQUENT) C,
            TABLE(T.ANTECEDENT) A
  ORDER BY SUPPORT DESC, LIFT DESC;
  
-- #199 SQL로 머신러닝 구현하기(21) : K-MEANS
-- 토마토가 채소와 과일, 단백질 중에 어느클래스에 속하는지 K-MEANS로 해보기
-- 테이블 생성
DROP TABLE FRUIT;

CREATE TABLE FRUIT
( F_ID    NUMBER(10),
 F_NAME  VARCHAR2(10),
 SWEET   NUMBER(10),
 CRISPY  NUMBER(10),
 F_CLASS  VARCHAR2(10) );

INSERT INTO FRUIT VALUES( 1, '사과', 10, 9, '과일');
INSERT INTO FRUIT VALUES( 2, '베이컨', 1, 4, '단백질');
INSERT INTO FRUIT VALUES( 3, '바나나', 10, 1, '과일');
INSERT INTO FRUIT VALUES( 4, '당근', 7, 10, '채소');
INSERT INTO FRUIT VALUES( 5, '셀러리', 3, 10, '채소');
INSERT INTO FRUIT VALUES( 6, '치즈', 1, 1, '단백질');
INSERT INTO FRUIT VALUES( 7, '토마토', 6, 7, NULL);
COMMIT;

-- 머신러닝 환경구성 테이블을 생성
DROP TABLE SETTINGS_KM1;

CREATE TABLE SETTINGS_KM1
AS
SELECT *
   FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
   WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

   INSERT INTO SETTINGS_KM1
      VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_KMEANS');

   INSERT INTO SETTINGS_KM1
      VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

    INSERT INTO SETTINGS_KM1
      VALUES (DBMS_DATA_MINING.CLUS_NUM_CLUSTERS, 3);

   COMMIT;

END;
/

-- 머신러닝 모델을 생성
BEGIN
 DBMS_DATA_MINING.DROP_MODEL('MD_KM_MODEL1');
END;
/

BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_KM_MODEL1',
      MINING_FUNCTION       => DBMS_DATA_MINING.CLUSTERING,
      DATA_TABLE_NAME       => 'FRUIT',
      CASE_ID_COLUMN_NAME   => 'F_ID',
      TARGET_COLUMN_NAME    => NULL,
      SETTINGS_TABLE_NAME   => 'SETTINGS_KM1');
END;
/

DROP TABLE KMEANS_RESULT1;

BEGIN
   DBMS_DATA_MINING.APPLY (MODEL_NAME => 'MD_KM_MODEL1',
                                          DATA_TABLE_NAME => 'FRUIT',
                                          CASE_ID_COLUMN_NAME => 'F_ID',
                                          RESULT_TABLE_NAME => 'KMEANS_RESULT1');
END;
/


-- 머신러닝 모델이 분류한 결과를 확인
SELECT T2.F_NAME,
          T2.F_CLASS,
          T1.CLUSTER_ID,
          T1.PROBABILITY,
          T2.SWEET,
          T2.CRISPY
  FROM (SELECT F_ID, CLUSTER_ID, PROBABILITY
              FROM (SELECT T.*,
                                  MAX (PROBABILITY)  OVER (PARTITION BY F_ID 
                                                                       ORDER BY PROBABILITY DESC) MAXP
                          FROM KMEANS_RESULT1 T)
                          WHERE MAXP = PROBABILITY) T1, FRUIT T2
  WHERE T1.F_ID = T2.F_ID 
  ORDER BY CLUSTER_ID;
  
-- #200 SQL로 머신러닝 구현하기(22) : K-MEANS
-- 미국 시카오 지역의 순찰 지역 범위 지정해보기
-- 학습 테이블 생성
DROP TABLE CHICAGO_CRIME; 

CREATE TABLE CHICAGO_CRIME
( C_ID	   NUMBER(10),
 CASE_NUMBER  VARCHAR2(10),
 CRIME_DATE    VARCHAR2(40), 
 PRIMARY_TYPE  VARCHAR2(40),
 DESCRIPTION   VARCHAR2(80),
 LOCATION_DESCRIPTION   VARCHAR2(50),	
 ARREST_YN    VARCHAR2(10),
 DOMESTIC     VARCHAR2(10),
 FBI_CODE      VARCHAR2(10),
 CRIME_YEAR   VARCHAR2(10),	
 LATITUDE      NUMBER(20,10),	
 LONGITUDE    NUMBER(20,10) 
);


--- Chicago_Crimes_2012_to_2017.csv 데이터를 입력합니다. 
SELECT COUNT(*) FROM CHICAGO_CRIME;


-- 머신러닝 구성 정보 테이블을 생성
DROP TABLE SETTINGS_KM2;

CREATE TABLE SETTINGS_KM2
AS
SELECT *
   FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
   WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

   INSERT INTO SETTINGS_KM2
      VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_KMEANS');

   INSERT INTO SETTINGS_KM2
      VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

    INSERT INTO SETTINGS_KM2
      VALUES (DBMS_DATA_MINING.CLUS_NUM_CLUSTERS, 14);

   COMMIT;

END;
/


-- 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_GLM_MODEL2');
END;
/

DROP TABLE KMEANS_RESULT2;

CREATE OR REPLACE VIEW VW_CHICAGO_CRIME
AS 
  SELECT C_ID, LATITUDE, LONGITUDE
    FROM CHICAGO_CRIME;

BEGIN 

   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_GLM_MODEL2',
      MINING_FUNCTION       => DBMS_DATA_MINING.CLUSTERING,
      DATA_TABLE_NAME       => 'VW_CHICAGO_CRIME',
      CASE_ID_COLUMN_NAME   => 'C_ID',
      TARGET_COLUMN_NAME    => NULL,
      SETTINGS_TABLE_NAME   => 'SETTINGS_KM2');
END;
/

-- 생성한 머신러닝 모델로 군집화 
BEGIN
   DBMS_DATA_MINING.APPLY (MODEL_NAME => 'MD_GLM_MODEL2',
                                         DATA_TABLE_NAME => 'VW_CHICAGO_CRIME',
                                         CASE_ID_COLUMN_NAME => 'C_ID',
                                         RESULT_TABLE_NAME => 'KMEANS_RESULT2');
END;
/

-- 머신러닝 모델이 군집화한 결과를 확인
SELECT T1.C_ID,
          T1.CLUSTER_ID,
          T1.PROBABILITY,
          T2.LATITUDE,
          T2.LONGITUDE
  FROM (SELECT C_ID, CLUSTER_ID, PROBABILITY
              FROM (SELECT T.*,
                                  MAX (PROBABILITY) OVER (PARTITION BY C_ID 
                                                                    ORDER BY PROBABILITY DESC) MAXP
                          FROM KMEANS_RESULT2 T)
            WHERE MAXP = PROBABILITY) T1, CHICAGO_CRIME T2
 WHERE T1.C_ID = T2.C_ID ORDER BY CLUSTER_ID;

-- 14개의 군집 번호와 군집번호별 건수를 확인
SELECT   T1.CLUSTER_ID , COUNT(*)
FROM (SELECT C_ID, CLUSTER_ID, PROBABILITY
            FROM (SELECT T.*,
                                MAX (PROBABILITY) OVER (PARTITION BY C_ID 
                                                                    ORDER BY PROBABILITY DESC) MAXP
                        FROM KMEANS_RESULT2 T)
           WHERE MAXP = PROBABILITY) T1, CHICAGO_CRIME T2
  WHERE T1.C_ID = T2.C_ID 
  GROUP BY T1.CLUSTER_ID;
